using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Gotham.Extensions.Core.Entities;

[Generator]
public class EntityKeyGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var entityKeysToGenerate = context.SyntaxProvider.ForAttributeWithMetadataName(
			typeof(EntityKeyAttribute).FullName!,
			predicate: static (_, _) => true,
			transform: static (ctx, _) =>
				GetEntityKeyToGenerate(ctx.SemanticModel, ctx.TargetNode, ctx.Attributes));

		context.RegisterSourceOutput(entityKeysToGenerate, (spc, model) =>
		{
			if (model is not null)
			{
				var result = $@"// -------------------------------------------------------
// <auto-generated file=""{model.FileName}.g,cs"" />
// This code was generated by a tool.
// Changes to this file may cause incorrect behavior and
// will be lost if the code is regenerated.
// -------------------------------------------------------

using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using {typeof(EntityKeyAttribute).Namespace};

namespace {model.TypeNamespace}
{{
	[JsonConverter(typeof({model.TypeName}JsonConverter))]
	public readonly partial record struct {model.TypeName}
	{{
		private const string Prefix = ""{model.Prefix}"";
		private const string Suffix = ""{model.Suffix}"";

		private readonly Ulid _value;

		private {model.TypeName}(Ulid value)
		{{
			_value = value;
		}}
		
		public static {model.TypeName} New()
		{{
			return new {model.TypeName}(Ulid.NewUlid());
		}}

		public static {model.TypeName} Parse(string value)
		{{
			if (TryParse(value, out var entityKey))
				return entityKey;

			throw new ArgumentException($""Cannot parse '{{value}}' into type {model.TypeName}."");
		}}

		public static {model.TypeName} Parse(Guid value)
		{{
			if (TryParse(value, out var entityKey))
				return entityKey;
			
			throw new ArgumentException($""Cannot parse '{{value}}' into type {model.TypeName}."");
		}}

		public static bool TryParse(string value, out {model.TypeName} entityKey)
		{{
			// extract ulid value from string
			var entityKeyRawValue = {typeof(EntityKeyExtensions).FullName}.ExtractEntityKeyRawValue(value, Prefix, Suffix);

			if (Ulid.TryParse(entityKeyRawValue, out var ulid))
			{{
				entityKey = new {model.TypeName}(ulid);
				return true;
			}}

			if (Guid.TryParse(entityKeyRawValue, out var guid))
			{{
				entityKey = new {model.TypeName}(new Ulid(guid));
				return true;
			}}

			entityKey = default;
			return false;
		}}

		public static bool TryParse(Guid value, out {model.TypeName} entityKey)
		{{
			entityKey = new {model.TypeName}(new Ulid(value));
			return true;
		}}

		public override string ToString()
		{{
			return $""{{Prefix}}{{_value}}{{Suffix}}"";
		}}
	}}

	public class {model.TypeName}JsonConverter : JsonConverter<{model.TypeName}>
	{{
		public override {model.TypeName} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
			=> {model.TypeName}.Parse(reader.GetString());

		public override void Write(Utf8JsonWriter writer, {model.TypeName} value, JsonSerializerOptions options)
			=> writer.WriteStringValue(value.ToString());
	}}
}}";

				spc.AddSource($"{model.FileName}.g.cs", SourceText.From(result, Encoding.UTF8));
			}
		});
	}

	private static EntityKey? GetEntityKeyToGenerate(SemanticModel model, SyntaxNode targetNode,
		ImmutableArray<AttributeData>                              attributes)
	{
		if (model.GetDeclaredSymbol(targetNode) is not INamedTypeSymbol symbol)
			return null;

		var fileName      = symbol.ToString();
		var typeName      = symbol.Name;
		var typeNamespace = symbol.ContainingNamespace.ToString();

		var attribute = attributes.First();

		var prefix = attribute.NamedArguments.FirstOrDefault(kvp =>
			kvp.Key == nameof(EntityKeyAttribute.Prefix)).Value.Value?.ToString() ?? string.Empty;

		var suffix = attribute.NamedArguments.FirstOrDefault(kvp =>
			kvp.Key == nameof(EntityKeyAttribute.Suffix)).Value.Value?.ToString() ?? string.Empty;

		return new EntityKey(fileName, typeName, typeNamespace, prefix, suffix);
	}
}